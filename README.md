#cgrading
##Description
A suite of tools useful for grading C programming assignments.
##Dependencies
* [argparse](https://pypi.python.org/pypi/argparse/1.3.0)
   \*if your python version is < 2.7

##Installation
Simply run the installation script:

`install.sh`

This will create **hard** links to each of the tools, with their "(pl|py)" filename
endings removed in your ~/bin directory. This is running under the assumption that
you have a ~/bin directory in the first place. If you do not, run the following commands:

`mkdir ~/bin`
`echo 'export PATH=PATH/home/foo/bin' >> .bashrc`

For user "foo" who uses the bash shell. This is also assuming that you don't already
have PATH setup within the rc file of your favourite shell, in which case simply
modify it to include ~/bin.

Now open up a new shell so the path is properly modified, and ta-da! You can run each
of the scripts wherever you want.

##Toy Example
* Please note that each of the below examples are run from the directory *containing*
the directory filled with student files. So if we did an `ls` here, if the student
directory is called **section2**, that's one of the files that would show up.
###Preprocessing
Say you just downloaded 100 assignments from the internet (supposedly Blackboard). Assume
they are all organised into directories, or if they aren't, you (unfortunately) manually
made them yourself. Execute:

``nospaces``

This will replace the spaces within a student's filename with underscores, 
under _all_ directories they submit, within the current directory. 
This is **very** important, as several of these grading scripts rely on there 
being no spaces. Plus, spaces are a headache anyway.

If they're zipfiles, you will want to do ``unzipper`` then run ``nospaces`` again to
remove all the spaces within the files that were extracted from the archives. Currently
other compression formats like tar and gz aren't supported, so make sure to tell your
students to turn in zip files! ``unzipper`` creates directories using the prefix
of each zip filename and stores the decompressed files in them.

###Compilation
Now that we've got all our stuff taken care of, it is time to compile their programs.
Let's assume that they were given a driver file, _driver.c_, that they didn't have
to turn in. Normally, you would have to get a little angry and write a long command
line to deal with it, but now you don't need to! Let's also assume that there was
also a header file provided that _also_ wasn't required for turnin, _driver.h_. To
compile all student programs under the directory, execute:

`ccompile -o driver.c --headers driver.h -r section2`

`-o` specifies "other files" required for compilation, like other C source code files.
`--headers` is self-explanatory: it allows you to specify a list of header files
required for compilation.
`-r` is the _root_ of the directory with student code inside.

Essentially, this command will execute something like 
`gcc  -o section2/bobsDirectory/run bob.c driver.c`

In all student directories where there is C source code. _Any number_ of C source
code files are globbed together where "bob.c" is. In this example, as long as there
is a "main" defined somewhere, we are fine. So how are header files accounted for?
We symbolically link all *missing* header files, as specified from the `--headers`
option, to the student's directory of code, so that GCC is happy.

###Output Generation
Now that we've got all that compiling taken care of, we need to run everyone's code!
Assume that the student program takes input from a file called "input.txt". To run
*all* student programs with this as the input file, we do:

`genout -i input.txt -r section2`. Now, if they also accepted command line arguments
with *or* without switches, say something like `-c 5`, we can run their executables
with this as well:

`genout -i input.txt -r section2 -a '-c 5'`

*Notice* how I enclosed these command line arguments in single quotes. This is
very important, if we didn't do it, genout would try to interpret -c as a command
line switch, and (in its current state) fail to execute.

###Diffing
After generating the output, one *could* go ahead and look through everything,
however that is quite a bother. With certain programs, one could diff their
output with the correct answers to discern what is right and wrong.

In order to do this, assuming we have a file with the correct answers, named
"answers.txt":

`differ -a answers.txt -r section2`

Which will diff the output files generated by *genout* with answers.txt.

###Conventions
The executable generated by `ccompile` is by default, "run", which is the default
executable name used by genout as well. However, this can be changed.

The output files generated by `genout` are called "myout", and the diff files generated
by "differ" are called "check.diff". These names can all be configured to your own
liking. Invoke the commands with the -h switch (or simply look at the source code)
for more details.
